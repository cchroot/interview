<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 基础知识点 | 小墨鱼的面试笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/interview/egg.png">
    <meta name="description" content="小墨鱼的面试笔记">
    
    <link rel="preload" href="/interview/assets/css/0.styles.41202823.css" as="style"><link rel="preload" href="/interview/assets/js/app.315fcd90.js" as="script"><link rel="preload" href="/interview/assets/js/3.2951d97b.js" as="script"><link rel="preload" href="/interview/assets/js/8.06e19e8e.js" as="script"><link rel="prefetch" href="/interview/assets/js/10.7ffca870.js"><link rel="prefetch" href="/interview/assets/js/11.a796a1e1.js"><link rel="prefetch" href="/interview/assets/js/12.c1a92f5b.js"><link rel="prefetch" href="/interview/assets/js/13.e23fb603.js"><link rel="prefetch" href="/interview/assets/js/14.6fe10376.js"><link rel="prefetch" href="/interview/assets/js/15.39fcb4a0.js"><link rel="prefetch" href="/interview/assets/js/16.a28d5ced.js"><link rel="prefetch" href="/interview/assets/js/17.a2ae2507.js"><link rel="prefetch" href="/interview/assets/js/18.f4d5c0b7.js"><link rel="prefetch" href="/interview/assets/js/19.9675a5ad.js"><link rel="prefetch" href="/interview/assets/js/2.51e9aef8.js"><link rel="prefetch" href="/interview/assets/js/20.eff5de6d.js"><link rel="prefetch" href="/interview/assets/js/21.39b07448.js"><link rel="prefetch" href="/interview/assets/js/22.2526b024.js"><link rel="prefetch" href="/interview/assets/js/23.e582a7d7.js"><link rel="prefetch" href="/interview/assets/js/24.6fab991d.js"><link rel="prefetch" href="/interview/assets/js/25.a11720bf.js"><link rel="prefetch" href="/interview/assets/js/26.ad35af4b.js"><link rel="prefetch" href="/interview/assets/js/27.a807c0ff.js"><link rel="prefetch" href="/interview/assets/js/28.43ec09a9.js"><link rel="prefetch" href="/interview/assets/js/29.40a4c8d6.js"><link rel="prefetch" href="/interview/assets/js/30.80f06240.js"><link rel="prefetch" href="/interview/assets/js/31.e254c535.js"><link rel="prefetch" href="/interview/assets/js/32.becfed3a.js"><link rel="prefetch" href="/interview/assets/js/33.169d624d.js"><link rel="prefetch" href="/interview/assets/js/34.e75ce0f2.js"><link rel="prefetch" href="/interview/assets/js/35.cfd2a91d.js"><link rel="prefetch" href="/interview/assets/js/36.813fc716.js"><link rel="prefetch" href="/interview/assets/js/37.1834af1c.js"><link rel="prefetch" href="/interview/assets/js/38.b3a019c6.js"><link rel="prefetch" href="/interview/assets/js/39.c64b6de1.js"><link rel="prefetch" href="/interview/assets/js/4.4edc6fe1.js"><link rel="prefetch" href="/interview/assets/js/40.20696ba5.js"><link rel="prefetch" href="/interview/assets/js/41.364a730f.js"><link rel="prefetch" href="/interview/assets/js/42.ee2aef05.js"><link rel="prefetch" href="/interview/assets/js/43.752ba15f.js"><link rel="prefetch" href="/interview/assets/js/44.667525a3.js"><link rel="prefetch" href="/interview/assets/js/45.b2834a73.js"><link rel="prefetch" href="/interview/assets/js/46.f874b150.js"><link rel="prefetch" href="/interview/assets/js/47.b7dd2d1e.js"><link rel="prefetch" href="/interview/assets/js/48.0b79ef3e.js"><link rel="prefetch" href="/interview/assets/js/49.bb77babc.js"><link rel="prefetch" href="/interview/assets/js/5.5f1bafd5.js"><link rel="prefetch" href="/interview/assets/js/50.66c1fd87.js"><link rel="prefetch" href="/interview/assets/js/51.15241f09.js"><link rel="prefetch" href="/interview/assets/js/52.0d2383ca.js"><link rel="prefetch" href="/interview/assets/js/53.439b2bec.js"><link rel="prefetch" href="/interview/assets/js/6.8b1e859e.js"><link rel="prefetch" href="/interview/assets/js/7.2e1d4b27.js"><link rel="prefetch" href="/interview/assets/js/9.98b67c20.js">
    <link rel="stylesheet" href="/interview/assets/css/0.styles.41202823.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/interview/" class="home-link router-link-active"><img src="/interview/egg.png" alt="小墨鱼的面试笔记" class="logo"> <span class="site-name can-hide">小墨鱼的面试笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/interview/pages/interview notes/JS 基础知识点.html" class="nav-link">
  面试笔记
</a></div><div class="nav-item"><a href="/interview/pages/interview questions/js基础面试题.html" class="nav-link">
  精选面试题
</a></div><div class="nav-item"><a href="https://github.com/cchroot/interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/interview/pages/interview notes/JS 基础知识点.html" class="nav-link">
  面试笔记
</a></div><div class="nav-item"><a href="/interview/pages/interview questions/js基础面试题.html" class="nav-link">
  精选面试题
</a></div><div class="nav-item"><a href="https://github.com/cchroot/interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/JS 基础知识点.html" class="active sidebar-link">基础知识点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/pages/interview notes/JS 进阶知识点.html" class="sidebar-link">JS 进阶知识点</a></li><li><a href="/interview/pages/interview notes/JS 异步编程.html" class="sidebar-link">异步编程</a></li><li><a href="/interview/pages/interview notes/浏览器与Node的事件循环Event Loop.html" class="sidebar-link">浏览器与Node的事件循环(Event Loop)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS手写相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/JS 手写相关.html" class="sidebar-link">JS 手写大全</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>性能优化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/性能优化总结.html" class="sidebar-link">性能优化总结</a></li><li><a href="/interview/pages/interview notes/网络协议相关优化.html" class="sidebar-link">网络协议相关优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/浏览器基础知识点.html" class="sidebar-link">浏览器基础知识点</a></li><li><a href="/interview/pages/interview notes/浏览器缓存机制.html" class="sidebar-link">浏览器缓存机制</a></li><li><a href="/interview/pages/interview notes/浏览器渲染原理.html" class="sidebar-link">浏览器渲染原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTTP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/http.html" class="sidebar-link">HTTP知识整合</a></li><li><a href="/interview/pages/interview notes/从输入url到页面展示到底发生了什么.html" class="sidebar-link">从输入url到页面展示到底发生了什么</a></li><li><a href="/interview/pages/interview notes/从输入url开始能做哪些优化.html" class="sidebar-link">从输入url开始能做哪些优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/安全防范知识点.html" class="sidebar-link">安全防范知识点</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>监控</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/前端监控.html" class="sidebar-link">前端监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue And React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/你能实现一个没有漏洞的双向绑定吗.html" class="sidebar-link">你能实现一个没有漏洞的双向绑定吗</a></li><li><a href="/interview/pages/interview notes/vue源码阅读笔记.html" class="sidebar-link">vue源码阅读笔记</a></li><li><a href="/interview/pages/interview notes/vueRouter源码阅读笔记.html" class="sidebar-link">vueRouter源码阅读笔记</a></li><li><a href="/interview/pages/interview notes/vuex源码阅读笔记.html" class="sidebar-link">vuex源码阅读笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/Webpack 性能优化.html" class="sidebar-link">Webpack 性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>nginx</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/nginx.html" class="sidebar-link">nginx 操作总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>redis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/一篇文章入门 redis（万字长文干货）.html" class="sidebar-link">一篇文章入门 redis（万字长文干货）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其它</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/interview notes/一篇文章搞定 javascript 正则表达式.html" class="sidebar-link">一篇文章搞定 javascript 正则表达式</a></li><li><a href="/interview/pages/interview notes/interview.html" class="sidebar-link">很久很久以前的面试复习一</a></li><li><a href="/interview/pages/interview notes/interview2.html" class="sidebar-link">很久很久以前的面试复习二</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-基础知识点"><a href="#js-基础知识点" class="header-anchor">#</a> JS 基础知识点</h1> <h3 id="_1、js-中存在-7-种原始类型"><a href="#_1、js-中存在-7-种原始类型" class="header-anchor">#</a> 1、js 中存在 7 种原始类型</h3> <p>boolean,null,undefined,number,string,symbol,bigint；typeof null 会输出 object,但是这只是 JS 存在的一个悠久 Bug</p> <h3 id="_2、判断类型"><a href="#_2、判断类型" class="header-anchor">#</a> 2、判断类型</h3> <p>JS 检测数据类型的 4 种方式：</p> <ul><li>typeof</li> <li>instanceof</li> <li>constructor</li> <li>Object.prototype.toString.call()</li></ul> <p>这里是对这四种方法的简要介绍以及它们在不同场景下的用途、优点和缺点：</p> <p><strong>typeof：</strong></p> <ul><li>用途：typeof是一元操作符，用于检测给定值的数据类型。</li> <li>优点：简单、快速，并且对于大多数基本数据类型（如字符串、数字、布尔值、函数）有效。</li> <li>缺点：对于复杂数据类型（如数组、对象、null），返回的结果并不具体，都会返回&quot;object&quot;。此外，对于函数来说，返回的是&quot;function&quot;，而不是&quot;object&quot;。</li></ul> <p><strong>instanceof：</strong></p> <ul><li>用途：instanceof用于检测对象是否属于某个特定的构造函数。</li> <li>优点：可以判断对象是否是特定构造函数的实例，适用于自定义类型的检测。</li> <li>缺点：不能准确判断基本数据类型，也不能判断两个不同的全局执行环境中创建的对象。</li></ul> <p><strong>constructor：</strong></p> <ul><li>用途：constructor是对象的属性，指向创建该对象的构造函数。</li> <li>优点：可以判断对象的构造函数，适用于自定义类型的检测。</li> <li>缺点：当对象的原型被修改时，constructor属性可能会失效。此外，对于基本数据类型和null，无法使用该方法进行检测。</li></ul> <p><strong>Object.prototype.toString.call()：</strong></p> <ul><li>用途：通过调用 Object.prototype.toString 方法，可以返回一个表示对象类型的字符串。</li> <li>优点：可以准确判断各种数据类型，包括基本数据类型、内置对象、自定义对象以及特殊的对象（如数组、日期等）。</li> <li>缺点：使用起来相对繁琐，需要调用特定的方法。</li></ul> <p>其中最通用的办法是运用<code>Object.prototype.toString.call()</code></p> <h3 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="header-anchor">#</a> 基本数据类型和引用数据类型的区别？</h3> <table><thead><tr><th>比较</th> <th>基本数据类型</th> <th>引用数据类型</th></tr></thead> <tbody><tr><td>数据存放位置</td> <td>基本数据类型存放在栈中，数据大小确定，内存空间大小可以分配</td> <td>引用数据类型存放在堆中，每个空间大小不一样，要根据情况进行特定的配置</td></tr> <tr><td>变量存储内容</td> <td>变量中存储的是值本身</td> <td>变量存储的是地址</td></tr> <tr><td>变量用来赋值时</td> <td>把变量的值复制一份去赋值</td> <td>把变量的内存地址复制一份去赋值</td></tr> <tr><td>存储内容大小</td> <td>存储值较小</td> <td>存储值较大</td></tr></tbody></table> <p>栈和堆的的介绍</p> <table><thead><tr><th>比较</th> <th>栈（线程）</th> <th>堆（进程，线程共享）</th></tr></thead> <tbody><tr><td>大小固定</td> <td>创建时，确定大小（值大小固定），故可能会溢出</td> <td>大小不固定，可随时增加</td></tr> <tr><td>存储类型</td> <td>存储基本数据类型及引用类型数据的堆地址</td> <td>存储引用类型数据，当一个引用类型的数据不再被引用时，垃圾回收机制会自动回收这部分内存</td></tr> <tr><td>如何访问</td> <td>按值访问</td> <td>按引用（堆内存地址）访问</td></tr> <tr><td>特点</td> <td>空间小，运行效率高</td> <td>空间大，运行效率相对较低</td></tr> <tr><td>存放规则</td> <td>按顺序存放，先进后出</td> <td>无序存储，可根据引用（地址）直接获取</td></tr> <tr><td></td> <td></td> <td></td></tr></tbody></table> <p><strong>为什么要这样设计？</strong></p> <p>这种设计的主要考虑是出于性能和内存管理的角度：</p> <ol><li><p>堆的动态分配和释放：引用类型的数据大小不确定，需要在运行时动态分配内存空间。堆的设计可以灵活地处理对象的创建和销毁，避免了静态分配内存带来的空间浪费。</p></li> <li><p>栈的高效操作：基本类型和引用类型的变量引用存储在栈中，栈的操作速度较快，因为它使用了简单的指针操作。这种设计可以提高变量的访问速度和内存的利用效率。</p></li> <li><p>垃圾回收：JavaScript 中使用垃圾回收机制来自动回收不再使用的内存。堆的设计允许动态分配和释放内存，垃圾回收机制可以根据引用的情况自动回收不再使用的堆内存，避免了内存泄漏和资源浪费。</p></li></ol> <p>总的来说，堆和栈的设计在 JavaScript 中旨在提供灵活的内存管理和高效的操作，使得开发者可以更方便地处理不同类型的数据，并且在运行时能够自动管理内存的分配和释放。</p> <p>实例:</p> <p>基本类型和引用类型赋值的区别</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//10</span>
  a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//20 10</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>a 变量是基本数据类型,他在赋值是把 a 的值复制一份给到 b</li> <li>所以 b = 10 ，最后我们修改 a 的值，并不会响影到 b</li> <li></li></ul> <p><img src="/interview/assets/img/js_base_1.36372a70.png" alt="基本类型和引用类型赋值的区别"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;清心&quot;</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">34</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> obj2 <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment">//是把obj中地址赋值给obj2,两者指向的是同一个堆内存中地址</span>
  obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;小丽&quot;</span><span class="token punctuation">;</span> <span class="token comment">//操作是堆内存中的数据</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">===</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">,</span> obj2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//小丽 小丽</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>栈内存中存着变量 obj 对堆内存中的地址，而堆内存中存着对应地址的数据内容</p> <p><img src="/interview/assets/img/js_base_2.ef4e20b0.png" alt="基本类型和引用类型赋值的区别"></p> <p>当 obj2=obj 时，其实是把 obj 中保存的地址赋值给了 obj2,所以本质上 obj===obj2 比较时,比较的是地址，地址始终没有变，所以两者是全等的。</p> <p>我们在操 obj.name = '小丽' 时，操作的是堆内存中的数据，所以 obj.name 和 obj2.name 的值是一样的。</p> <h3 id="_3、关于条件判断"><a href="#_3、关于条件判断" class="header-anchor">#</a> 3、关于条件判断</h3> <p>在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象</p> <h3 id="_4、关于this指向"><a href="#_4、关于this指向" class="header-anchor">#</a> 4、关于this指向</h3> <p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。</p> <p>但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己：</p> <p>this 的指向可以按照以下顺序判断:</p> <p><strong>全局环境中的 this</strong></p> <p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window;</p> <p>node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {};</p> <p><strong>是否是 new 绑定</strong></p> <p>如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下:</p> <ul><li>构造函数返回值不是 function 或 object。new Super() 返回的是 this 对象。</li> <li>构造函数返回值是 function 或 object，new Super()是返回的是Super种返回的对象。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token string">'26'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 26</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token string">'2'</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>

<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token string">'26'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token comment">// {a:'2'}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person<span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  info
<span class="token punctuation">}</span>
<span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">28</span>
<span class="token keyword">var</span> info <span class="token operator">=</span> person<span class="token punctuation">.</span>info
<span class="token function">info</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token comment">// 20</span>
<span class="token function">info</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token comment">// 20</span>
<span class="token function">info</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">info</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// node 环境中：非严格模式 globao,严格模式 null</span>
  <span class="token comment">// 浏览器环境中：非严格模式 window, 严格模式为 null</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  info
<span class="token punctuation">}</span>
<span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">28</span>
<span class="token keyword">var</span> info <span class="token operator">=</span> person<span class="token punctuation">.</span>info
<span class="token comment">// 严格模式抛出错误</span>
<span class="token comment">// 非严格模式，node 下输出 undefined（因为全局的 age 不会挂在 global 上）</span>
<span class="token comment">// 非严格模式，浏览器环境下输出28（因为全局的 age 回挂在 window 上）</span>
person<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2O</span>
<span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 28 注意这里直接调用和赋值引用调用结果不同</span>
<span class="token function">info</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 28</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>注意：不管我们连续给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定：<code>fn.bind().bind(a)() // this 指向fn</code></p> <p><strong>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person<span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  info
<span class="token punctuation">}</span>
<span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">28</span>
person<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 20，执行的是隐式绑定</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</strong></p> <p>非严格模式： node环境，指向全局对象 global，浏览器环境，指向全局对象 window。</p> <p>严格模式：执行 undefined</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">28</span>
<span class="token comment">// 严格模式浏览器环境和node环境都抛错</span>
<span class="token comment">// 非严格模式：node下输出 undefined（因为全局的 age 不会挂在 global 上）</span>
<span class="token comment">// 非严格模式：浏览器环境下输出 28（因为全局的 age 回挂在 window 上）</span>
<span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>箭头函数的情况</strong></p> <p>箭头函数没有自己的this，继承外层上下文绑定的this。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  <span class="token function-variable function">info</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> info <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 20</span>

<span class="token keyword">let</span> info2 <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
<span class="token function">info2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 28</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_5、-和"><a href="#_5、-和" class="header-anchor">#</a> 5、== 和 ===</h3> <p>== 和 === 的区别是：对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换</p> <h3 id="_6、闭包"><a href="#_6、闭包" class="header-anchor">#</a> 6、闭包</h3> <p>闭包的定义：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</p> <p><a href="https://juejin.cn/post/6844903619595075592" target="_blank" rel="noopener noreferrer">闭包的应用场景<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>函数防抖</li> <li>使用闭包设计单例模式</li> <li>为多个组件独立属性</li> <li>设置私有变量</li> <li>拿到正确的值</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//10个10</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <h4 id="什么是作用域"><a href="#什么是作用域" class="header-anchor">#</a> 什么是作用域 ？</h4> <ul><li>作用域就是代码的执行环境。执行环境定义了变量或函数有没有权访问其他数据。</li> <li>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</li> <li>虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</li></ul> <p>比如特殊的全局执行环境中的变量对象 window 对象，因此所有全局变量和函数都作为 window 对象的属性和方法创建的。在 Node 环境中，全局执行环境是 global 对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> n <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sum 相当于window对象上的方法</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5  n相当于window对象的属性</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1  a相当于window对象的属性</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。</p> <p>而在函数执行之后，栈将被环境弹出，把控制权返回给之前的执行环境。</p> <h4 id="js-中作用域的分类"><a href="#js-中作用域的分类" class="header-anchor">#</a> JS 中作用域的分类</h4> <p>JS 中有 3 种类型的作用域：</p> <ul><li>全局作用域
<ul><li>编写在 script 标签中的 js 代码（或单独 js 文件），都是在全局作用域中。</li></ul></li> <li>局部作用域（函数作用域）
<ul><li>每调用一次函数就会创建一个新的私有函数作用域，形参和当前私有函数作用域中声明的变量都是私有变量，保存在内部的一个变量对象中。</li> <li>函数被调用时创建函数作用域，函数执行完毕后，函数作用域被销毁，保存在其中的变量和函数定义了随之被销毁（闭包除外，只有当闭包函数的引用次数为 0 时，闭包函数和闭包中的变量被销毁）</li> <li>函数里能访问函数外变量，但函数外部是不能访问函数里面的变量，闭包除外，闭包函数会记住它在定义时所处的环境</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数调用创建函数作用域，代码执行用，作用域和变量a,b,c销毁</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数调用创建函数作用域，代码执行用，作用域和变量a,b,c销毁</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">function</span> <span class="token function">checkWeight</span><span class="token punctuation">(</span><span class="token parameter">weight</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_weight</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	  weight <span class="token operator">&gt;</span> _weight <span class="token operator">?</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;过胖&quot;</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;ok达标&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> <span class="token constant">P1</span> <span class="token operator">=</span> <span class="token function">checkWeight</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用完毕，作用域和变量weight不会被销毁</span>
  <span class="token constant">P1</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用完毕，作用域和变量_weight会被销毁</span>

  <span class="token comment">// 如果我们在最后加上P1 = null，则垃圾回收器回在下一次清理内存时</span>
  <span class="token comment">//销毁掉 checkWeight 调用形成的作用域和作用域中的变量 weight。</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li>块级作用域
<ul><li>使用 let 或 const 关键字声明的变量，会形成块级作用域。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会报错，{}里是块级作用域，外面是访问不到里面的变量的</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i is not defined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul> <h4 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h4> <p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条）</p> <ul><li>作用域链的前端，始终都是当前执行的代码所在环境的变量对象</li> <li>作用域链中的下一个对象来自于外部环境，再下一个变量对象则来自下下一个外部环境，一直到全局执行环境</li> <li>全局执行环境的变量对象始终都是作用域链上的最后一个对象</li></ul> <p>作用域链查找：</p> <p>内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。</p> <ul><li>在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找</li> <li>如果在某个变量对象中找到则使用该变量对象中的变量值，如果没有找到，则会一直找到全局作用域。如果最后还找不到，就会报错。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2  自身没有，沿着作用域链向上找</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2  自身有，就用自身的</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//4  自身没有，沿着作用域链向上找，直到全局作用域中找到c=4</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="怎么理解-js-静态作用域和动态作用域"><a href="#怎么理解-js-静态作用域和动态作用域" class="header-anchor">#</a> 怎么理解 JS 静态作用域和动态作用域</h4> <ul><li>静态作用域：又称词法作用域，是指作用域在词法阶段就被确定了（函数定义的位置就决定了函数的作用域）不会改变，javascript 采用的是词法作用域。</li> <li>动态作用域：函数的作用域在函数调用时才决定的。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>说明 fn 中打印的是全局下的 a ，这也印证了 JavaScript 使用了静态作用域。</p> <p>静态作用域执行过程</p> <p>当执行 fn 函数时，先从内部的AO对象查找是否有a变量，如果没有，沿着作用域链往上查找(由于JavaScript是词法作用域)，上层为全局GO，所以结果打印1</p> <h3 id="_7、浅拷贝"><a href="#_7、浅拷贝" class="header-anchor">#</a> 7、浅拷贝</h3> <p>浅拷贝对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况;首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。</p> <h3 id="_8、深拷贝"><a href="#_8、深拷贝" class="header-anchor">#</a> 8、深拷贝</h3> <p>简单的深拷贝可以通过: <code>JSON.parse(JSON.stringify(object))</code> 来解决，该方法的局限性在：</p> <ol><li>会忽略 undefined</li> <li>会忽略 symbol</li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ol> <p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel，完全的深拷贝只能是采用递归遍历了，以下是一个简单实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查是否为基本数据类型或 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建一个新的对象或数组</span>
  <span class="token keyword">const</span> clone <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 遍历对象的属性</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归深拷贝子属性</span>
      clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
  address<span class="token operator">:</span> <span class="token punctuation">{</span>
    city<span class="token operator">:</span> <span class="token string">'New York'</span><span class="token punctuation">,</span>
    country<span class="token operator">:</span> <span class="token string">'USA'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> cloneObj <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cloneObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>上述实现是一个简化版的深拷贝函数，适用于大多数情况。然而，对于一些特殊情况，例如包含函数、循环引用或原型链属性的对象，可能需要额外的处理来确保正确的深拷贝。在实际应用中，可以根据具体需求对深拷贝函数进行进一步的扩展和优化。</p> <h3 id="_9、instanceof"><a href="#_9、instanceof" class="header-anchor">#</a> 9、instanceof</h3> <p>关于 instanceof 其实表示的就是一种继承关系，或者原型链的结构。Instanceof 运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为 B。Instanceof的判断规则是：沿着 A 的 <strong>proto</strong> 这条线来找，同时沿着 B 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true。如果找到终点还未重合，则返回 false。</p> <h3 id="_10、关于原型-需要记住这张图"><a href="#_10、关于原型-需要记住这张图" class="header-anchor">#</a> 10、关于原型，需要记住这张图</h3> <p>JavaScript 原型链是一种对象之间的关联机制，它是基于原型（prototype）的继承模型。每个 JavaScript 对象都有一个原型（prototype），并且可以通过原型链来访问和继承其他对象的属性和方法。</p> <p><img src="/interview/assets/img/prototype_1.a708f9c1.png" alt="原型"></p> <p>JavaScript 对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p> <p>原型链可以用于以下几个方面：</p> <ol><li>继承：通过原型链，可以实现对象之间的继承关系。一个对象可以作为另一个对象的原型，从而继承原型对象的属性和方法。</li> <li>属性和方法的共享：原型链使得多个对象可以共享同一个原型对象的属性和方法，避免了重复定义和占用额外的内存空间。</li> <li>对象的扩展：通过修改原型对象，可以动态地为对象添加新的属性和方法，从而实现对象的扩展。</li> <li>原型链的访问和修改：可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 方法来访问和修改对象的原型链。</li></ol> <p>总之，原型链是 JavaScript 中实现继承和属性共享的重要机制，它使得对象可以通过原型链向上查找属性和方法，实现代码的重用和扩展。</p> <h3 id="_11、-var、let、const的区别"><a href="#_11、-var、let、const的区别" class="header-anchor">#</a> 11、 var、let、const的区别</h3> <ol><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li> <li>var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用</li> <li>var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会</li> <li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值</li></ol> <p><strong>const 定义的值一定是不能改变的吗？</strong></p> <ul><li>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个栈内存地址所保存的数据不得改动。</li> <li>对于简单类型的数据（数值、字符串、布尔值）值就保存在变量指向的那个栈内存地址，因此等同于常量。</li> <li>引用类型的数据（主要是对象和数组）变量指向的栈内存地址，保存的只是一个指向实际数据的指针</li> <li>const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</li></ul> <p>所以如果是 const 声明的是一个引用类型的变量，其引用类型的结构是可以发生改变的。</p> <p>例如：用const 声明一个数组，还能继续 push 元素到数组中；</p> <ul><li>因为 const 声明的变量保存的只是栈内存中的地址，只是一个指向实际数据的指针。指针指向堆内存中保存的数据。</li> <li>const 只能保证栈内存中的地址不变，但是堆内存中的数据如何改变是没有办法控制的。</li> <li>push 方法相当于是改变了堆内存中的数据结构。</li></ul> <h3 id="_12、组合继承"><a href="#_12、组合继承" class="header-anchor">#</a> 12、组合继承</h3> <p>核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p> <h3 id="_13、寄生组合继承"><a href="#_13、寄生组合继承" class="header-anchor">#</a> 13、寄生组合继承</h3> <p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> Child<span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 或者</span>
<span class="token comment">// Child.prototype = Object.create(Parent.prototype);</span>
<span class="token comment">// Child.prototype.constructor = Child;</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p> <h3 id="_14、class-继承"><a href="#_14、class-继承" class="header-anchor">#</a> 14、Class 继承</h3> <p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。不过，之前也说了在 JS 中并不存在类，所以 class 的本质就是函数。</p> <h3 id="_15、模块化"><a href="#_15、模块化" class="header-anchor">#</a> 15、模块化</h3> <ol><li>模块化带来的好处：解决命名冲突；提供复用性；提高代码可维护性</li> <li>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</li> <li>AMD 和 CMD</li> <li>CommonJS：CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了</li> <li>ES Module</li></ol> <h3 id="_16、proxy"><a href="#_16、proxy" class="header-anchor">#</a> 16、Proxy</h3> <p>在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。 Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p> <h3 id="_17、事件冒泡与捕获"><a href="#_17、事件冒泡与捕获" class="header-anchor">#</a> 17、事件冒泡与捕获</h3> <p>浏览器里面的事件都会按照一定的规则去传递，不管 body 上绑定事件、或者 div 甚至 div 的 text 节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡，如图：</p> <p><img src="/interview/assets/img/event_rule_1.973dbf8c.png" alt="浏览器事件传递规则"></p> <p>一句话概括这种机制：</p> <ul><li>捕获：自外而内，从根到叶，从大到小</li> <li>冒泡：自内而外，从叶到根，从小到大</li></ul> <p>还需要注意的是，并不是所有的事件都会冒泡,以下事件就没有：</p> <ul><li>onblur</li> <li>onfocus</li> <li>onmouseenter</li> <li>onmouseleave</li></ul> <h3 id="_18、关于事件代理-事件委托"><a href="#_18、关于事件代理-事件委托" class="header-anchor">#</a> 18、关于事件代理（事件委托）</h3> <p>事件代理是通过监听一个父元素，来给不同的子元素绑定事件，减少监听次数，从而提升浏览器速度。需要注意的是：如果元素被阻止冒泡了，千万别去用事件委托的方式监听事件，因为事件委托的原理是利用事件冒泡，当冒泡被阻止，就无法监听了。</p> <h3 id="回调和promise的区别"><a href="#回调和promise的区别" class="header-anchor">#</a> 回调和promise的区别</h3> <p>Promise和Callback都是用于处理异步操作的机制，但它们有一些区别。</p> <p>回调（Callback）：
回调是一种传递函数作为参数的方式，用于在异步操作完成后执行特定的逻辑。
回调函数通常在异步操作完成时被调用，接收结果或错误作为参数。
回调函数的执行顺序和上下文可能难以控制，尤其在处理多个嵌套的回调时，可能导致回调地狱（Callback Hell）的问题。
回调函数没有内置的错误处理机制，需要手动处理错误。
示例使用回调的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟异步操作</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递结果给回调函数</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Result:'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Promise：
Promise 是一种更为现代化的异步编程模式，它提供了一种更结构化和可读性更高的方式来处理异步操作。
Promise 是一个对象，代表一个异步操作的最终完成或失败的状态，并返回相应的结果或错误。
Promise 可以链式调用，通过 then() 方法处理操作成功的情况，通过 catch() 方法处理操作失败的情况。
Promise 提供了内置的错误处理机制，可以通过 catch() 方法捕获和处理错误，或者通过 finally() 方法执行清理操作。
示例使用 Promise 的代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成操作并传递结果</span>
      <span class="token comment">// 或者在出现错误时使用 reject(error) 来拒绝 Promise</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Result:'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>总结：</p> <p>回调是传递函数作为参数的方式，用于处理异步操作，但容易导致代码难以维护和阅读。
Promise 是一种更为结构化和可读性更高的异步编程模式，提供了内置的错误处理和链式调用的能力，使代码更具表达力和可维护性。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/interview/pages/interview notes/JS 进阶知识点.html">
        JS 进阶知识点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/interview/assets/js/app.315fcd90.js" defer></script><script src="/interview/assets/js/3.2951d97b.js" defer></script><script src="/interview/assets/js/8.06e19e8e.js" defer></script>
  </body>
</html>
